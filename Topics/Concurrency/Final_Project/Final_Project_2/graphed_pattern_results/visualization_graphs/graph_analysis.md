Average Time Taken vs Number of URLS analysis:

Based on the graph, we can clearly see that the higher the scale of URLS count we can see all methods' run time increase at different rates. Multiprocessing spiked the highest due to its slightly proportional scale and inefficiency when doing I/O tasks by spawning processes. For multiprocessing i used ProcessPoolExecutor with max_workers of 4 which is basically the count of my cpu cores, and as URLS scale, its still those 4 no change so that's why it's very inefficient and too much unnecessary process spawning overhead for I/O bound tasks. Threading did a decent job at large scale, but due to overhead of spawning lots of threads and context switching between threads and GIL limitation, it still make a visible increment in time taken to run when scale is becoming larger. While for mix, since it's the average of all methods, it's not the best nor worst, but still can't compete against threading since multiprocessing in it scales up the time taken to run too much. And then here comes asyncio, which is nearly flat line, which shows its excellence for I/O task due to its nature of event loop on a single thread which is super light weight and efficient for large scale I/O tasks.

Average Downloads/sec vs Number of URLS analysis:

Based on the graph, we can see the DPS (Downloads Per Second) of all methods scale up with URLS count thanks to the power of concurrency except for multiprocessing. For multiprocessing, at large scale like 1000 URLS it starts to show its decrease in DPS because it's not really doing the task concurrently, it's only suitable for CPU intensive tasks, the max_workers are still 4 as it scales up and the nature of spawning processes is super unnecessary for I/O tasks. For threading, it did a pretty great job, thanks to its concurrency but what pull it back is at large scale, it has to deal with too much threads spawning and context switching. And as we said before, the mix method is not best nor worst, it didn't perform as well as thread because as you know the multiprocessing pull it too much even thought it shares all 1/3 of all methods equally (or slightly equally due to not all number of tasks or divisible to 3 which might leave 1 or 2 method 1 less tasks but it doesn't matter much at large scale). And here is the king, Asyncio! Well yes at large scale as we can see from the previous graph we can see for asyncio that when the urls count 10x, the asyncio time taken only 1.5x thanks to concurrency which as well influence the great scale and spike of DPS to URLS count.